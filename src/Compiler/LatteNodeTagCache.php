<?php

namespace Northrook\Latte\Compiler;

use InvalidArgumentException;
use Northrook\Core\Timestamp;
use Northrook\Filesystem\File;
use Northrook\Logger\Log;
use Northrook\Resource\Path;
use Symfony\Component\VarExporter\Exception\ExceptionInterface;
use Symfony\Component\VarExporter\VarExporter;
use function Northrook\getProjectRootDirectory;

final class LatteNodeTagCache
{
    private readonly int $active_extension;
    private array        $nodeTags;

    public readonly Path $cacheFile;

    public function __construct(
        private readonly array $extensions = [],
    ) {
        $this->active_extension = \count( $this->extensions );
        $this->cacheFile        = new Path(
            \sys_get_temp_dir() . '/'
            . \hash( 'xxh3', getProjectRootDirectory() )
            . '/latteNodeTagsCache.cache',
        );
    }

    public function getCachedTags() : array {

        $this->loadCachedEntity();

        if ( $this->useCachedExtensions() && $this->hasData() ) {
            return $this->nodeTags[ 'data' ];
        }

        $nodeTagArray = $this->compileNodeTags();

        $this->save( $nodeTagArray );

        return $nodeTagArray;
    }

    public function clear() : void {
        $this->cacheFile->delete();
    }

    private function loadCachedEntity() : void {
        if ( $this->cacheFile->exists ) {
            $this->nodeTags ??= include $this->cacheFile->path;
        }
    }

    private function hasData() : bool {
        return isset( $this->nodeTags[ 'data' ] );
    }

    private function useCachedExtensions() : bool {
        return isset( $this->nodeTags[ 'extensions_count' ] ) &&
               $this->nodeTags[ 'extensions_count' ] === $this->active_extension;
    }

    private function compileNodeTags() : array {

        // Tags not visible in Latte\Extension
        $tags = [ 'n:if' ];

        // Get all tags from all provided extensions
        foreach ( $this->extensions as $extension ) {
            // Append keys
            $tags += \array_keys( $extension->getTags() );
        }

        // Only keep n: tags
        $tags = \array_filter( $tags, static fn ( $tag ) => \str_starts_with( $tag, 'n:' ) );

        // Deduplicate tags
        $tags = \array_flip( \array_flip( $tags ) );

        // For debugging
        Log::info( "Latte Loader: found {count} tags.", [ 'count' => \count( $tags ) ] );

        return \array_values( $tags );
    }

    private function save( array $array ) : void {

        $name      = 'nTag cache';
        $generated = new Timestamp();
        $generator = $this::class;
        $dataStore = $this->exportData( $name, $array, $generated );

        $content = <<<PHP
            <?php // $generated->unixTimestamp

            /*---------------------------------------------------------------------
            
               Name      : $name
               Generated : $generated->datetime

               This file is generated by $generator.

               Do not edit it manually.

            ---------------------------------------------------------------------*/

            return $dataStore;
            PHP;

        File::save( $this->cacheFile->path, $content );
    }

    final protected function exportData( string $name, array $data, Timestamp $generated ) : string {
        try {
            return VarExporter::export(
                [
                    'name'      => $name,
                    'path'      => $this->cacheFile,
                    'generator' => $this::class,
                    'generated' => $generated->datetime,
                    'timestamp' => $generated->unixTimestamp,
                    'type'      => \gettype( $data ),
                    'data'      => $data,
                ],
            );
        }
        catch ( ExceptionInterface $exception ) {
            throw new InvalidArgumentException(
                message  : "Unable to export the $name dataStore.",
                code     : 500,
                previous : $exception,
            );
        }
    }
}